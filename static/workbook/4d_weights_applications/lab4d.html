<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

  <meta charset="utf-8" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />

  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta name="author" content="Luc Anselin" />


  <title>Applications of Spatial Weights</title>

  <link href="lab4d_files/highlightjs-9.12.0/default.css" rel="stylesheet" />
  <script src="lab4d_files/highlightjs-9.12.0/highlight.js"></script>
  <title>GeoDa on Github</title>

  <style>
    * {
      margin: 0;
      padding: 0;
    }

    .shadowfilter {
      -webkit-filter: drop-shadow(12px 12px 7px rgba(0, 0, 0, 0.5));
      filter: url(shadow.svg#drop-shadow);
    }

    .intro1 {
      margin-left: -45px;
    }
  </style>
  <link rel="stylesheet" type="text/css" href="https://geodacenter.github.io/stylesheets/normalize.css" media="screen">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="https://geodacenter.github.io/stylesheets/stylesheet.css" media="screen">
  <link rel="stylesheet" type="text/css" href="https://geodacenter.github.io/stylesheets/github-light.css"
    media="screen">
  <link rel="stylesheet" href="https://geodacenter.github.io/stylesheets/simple-slideshow-styles.css">
  <style>
    ul {
      padding-left: 30px;
    }

    figcaption {
      top: .70em;
      left: .35em;
      bottom: auto !important;
      right: auto !important;
    }
  </style>

  <style>
    h1 {
      text-align: center;
    }

    h3.subtitle {
      text-align: center;
    }

    h4.author {
      text-align: center;
    }

    h4.date {
      text-align: center;
    }

    p.caption {
      font-size: 12px;
    }
  </style>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-LC0QJ53WFS"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-LC0QJ53WFS');
  </script>
  <!-- End Google tag -->

  <style type="text/css">
    code {
      white-space: pre;
    }
  </style>
  <script type="text/javascript">
    if (window.hljs) {
      hljs.configure({ languages: [] });
      hljs.initHighlightingOnLoad();
      if (document.readyState && document.readyState === "complete") {
        window.setTimeout(function () { hljs.initHighlighting(); }, 0);
      }
    }
  </script>





</head>

<body>


  <section class="main-content">


    <h1 class="title toc-ignore">Applications of Spatial Weights</h1>
    <h4 class="author"><em>Luc Anselin<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></em></h4>
    <h4 class="date"><em>03/17/2018 (revised and updated)</em></h4>


    <div id="TOC">
      <ul>
        <li><a href="#introduction">Introduction</a>
          <ul>
            <li><a href="#objectives">Objectives</a>
              <ul>
                <li><a href="#geoda-functions-covered">GeoDa functions covered</a></li>
              </ul>
            </li>
            <li><a href="#getting-started">Getting started</a></li>
          </ul>
        </li>
        <li><a href="#spatially-lagged-variables">Spatially lagged variables</a>
          <ul>
            <li><a href="#concept">Concept</a></li>
            <li><a href="#creating-a-spatially-lagged-variable">Creating a spatially lagged variable</a>
              <ul>
                <li><a href="#spatial-lag-with-row-standardized-weights">Spatial lag with row-standardized weights</a>
                </li>
                <li><a href="#spatial-lag-as-a-sum-of-neighboring-values">Spatial lag as a sum of neighboring values</a>
                </li>
                <li><a href="#spatial-window-average">Spatial window average</a></li>
                <li><a href="#spatial-window-sum">Spatial window sum</a></li>
              </ul>
            </li>
            <li><a href="#spatially-lagged-variables-from-inverse-distance-weights">Spatially lagged variables from
                inverse distance weights</a>
              <ul>
                <li><a href="#principle">Principle</a></li>
                <li><a href="#default-setting">Default setting</a></li>
                <li><a href="#spatial-lags-with-row-standardized-inverse-distance-weights">Spatial lags with
                    row-standardized inverse distance weights</a></li>
              </ul>
            </li>
            <li><a href="#spatially-lagged-variables-from-kernel-weights">Spatially lagged variables from kernel
                weights</a></li>
          </ul>
        </li>
        <li><a href="#spatial-rate-smoothing">Spatial rate smoothing</a>
          <ul>
            <li><a href="#principle-1">Principle</a></li>
            <li><a href="#preliminaries">Preliminaries</a></li>
            <li><a href="#digression---rescaling-coordinates">Digression - rescaling coordinates</a></li>
            <li><a href="#simple-window-average-of-rates">Simple window average of rates</a></li>
            <li><a href="#spatially-smoothed-rates">Spatially smoothed rates</a></li>
            <li><a href="#spatially-smoothed-rates-in-the-table">Spatially smoothed rates in the table</a></li>
          </ul>
        </li>
        <li><a href="#spatial-empirical-bayes-smoothing">Spatial Empirical Bayes smoothing</a>
          <ul>
            <li><a href="#principle-2">Principle</a></li>
            <li><a href="#spatial-eb-rate-smoother">Spatial EB rate smoother</a></li>
          </ul>
        </li>
        <li><a href="#references">References</a></li>
      </ul>
    </div>

    <p><br></p>
    <div id="introduction" class="section level2 unnumbered">
      <h2>Introduction</h2>
      <p>The main role for spatial weights is their use as the basis for the construction of various
        tests for spatial autocorrelation. These measures consist of compromises between attribute
        (variable) similarity and locational similarity, with the latter formally expressed through the spatial
        weights.</p>
      <p>However, the weights are also important for the
        creation of <em>spatially explicit</em> variables. These are variables that take into account
        the values observed at neighboring locations.</p>
      <p>There are two important applications for
        this. One pertains to the construction of so-called spatially lagged variables for
        inclusion in a spatial regression specification. The other yields an approach to smooth
        rates by borrowing strength from the values in neighboring observations. This takes the form
        of spatially smoothed rates. We consider each in
        turn.</p>
      <p>For the spatially lagged variables, we will continue to use the data set with point locations of house sales
        for Cleveland, OH. For the spatial smoothing examples, we will use the Ohio county lung
        cancer cases.</p>
      <div id="objectives" class="section level3 unnumbered">
        <h3>Objectives</h3>
        <ul>
          <li>
            <p>Create a spatially lagged variable as an average or sum of the neighbors</p>
          </li>
          <li>
            <p>Create a spatially lagged variable as a window sum or average</p>
          </li>
          <li>
            <p>Create a spatially lagged variable based on inverse distance weights</p>
          </li>
          <li>
            <p>Create a spatially lagged variable based on kernel weights</p>
          </li>
          <li>
            <p>Rescaling coordinates to obtain inverse distance weights</p>
          </li>
          <li>
            <p>Compute and map spatially smoothed rates</p>
          </li>
          <li>
            <p>Compute and map spatial Empirical Bayes smoothed rates</p>
          </li>
        </ul>
        <div id="geoda-functions-covered" class="section level4 unnumbered">
          <h4>GeoDa functions covered</h4>
          <ul>
            <li>Table &gt; Calculator &gt; Spatial Lag
              <ul>
                <li>select spatial weights</li>
                <li>row-standardized weights or not</li>
                <li>include diagonal or not</li>
              </ul>
            </li>
            <li>Map &gt; Rates-Calculated Map
              <ul>
                <li>Spatial Rate</li>
                <li>Spatial Empirical Bayes</li>
              </ul>
            </li>
            <li>Table &gt; Calculator &gt; Rates
              <ul>
                <li>Spatial Rate</li>
                <li>Spatial Empirical Bayes</li>
              </ul>
            </li>
          </ul>
          <p><br></p>
        </div>
      </div>
      <div id="getting-started" class="section level3 unnumbered">
        <h3>Getting started</h3>
        <p>To start, we continue to use the data set that contains the location and sales price of 205 homes in a core
          area of Cleveland, OH for the fourth quarter of 2015. We also need to have several spatial weights
          active in the weights manager. At the very least, we need k-nearest neighbor weights for k=6, inverse
          distance weights using the k-nearest neighbors with k=6, and Epanechnikov kernel weight, again using
          the adaptive kernel for k=6 nearest neighbors, and with the kernel applied
          to the diagonal weights (the diagonals will thus equal 0.75). We can either create these weights in the
          current project (after dropping the file <strong>clev_sls_154_core.shp</strong> into the <strong>Drop files
            here</strong> rectangle of the connect to data source dialog), or load a project file that contains the
          weights.</p>
        <p>In the example shown in Figure <a href="#fig:clevweights">1</a>, the three weights files are
          <strong>clev_sls_154_core_k6</strong> (for knn contiguity), <strong>clev_sls_154_core_k6id</strong> (for
          inverse distance
          applied to the k=6 nearest neighbors), and <strong>clev_sls_154_core_k6epadiag</strong> (for the Epanechnikov
          kernel weights). Figure <a href="#fig:clevweights">1</a> highlights the properties of the latter, as
          listed in the weights manager (note how the <strong>kernel to diagonal</strong> is set to
          <strong>true</strong>).
        </p>
        <div class="figure" style="text-align: center"><span id="fig:clevweights"></span>
          <img src="pics4d/0_858_defaultclevweights.png" alt="Spatial weights for Cleveland point data" width="60%" />
          <p class="caption">
            Figure 1: Spatial weights for Cleveland point data
          </p>
        </div>
      </div>
    </div>
    <div id="spatially-lagged-variables" class="section level2 unnumbered">
      <h2>Spatially lagged variables</h2>
      <div id="concept" class="section level3 unnumbered">
        <h3>Concept</h3>
        <p>With a neighbor structure defined by the non-zero elements of the
          spatial weights matrix <span class="math inline">\(\mathbf{W}\)</span>, a spatially lagged variable is a
          weighted sum or a weighted average of the neighboring values for that variable.
          In most commonly used notation,
          the spatial lag of <span class="math inline">\(y\)</span> is then expressed as <span
            class="math inline">\(Wy\)</span>.</p>
        <p>Formally, for observation <span class="math inline">\(i\)</span>,
          the spatial lag of <span class="math inline">\(y_i\)</span>, referred to as <span
            class="math inline">\([Wy]_i\)</span> (the variable <span class="math inline">\(Wy\)</span> observed for
          location
          <span class="math inline">\(i\)</span>) is:
          <span class="math display">\[\begin{equation*}
            [Wy]_i = w_{i1}y_1 + w_{i2}y_2 + \dots + w_{in}y_n,
            \end{equation*}\]</span>
          or,
          <span class="math display">\[\begin{equation*}
            [Wy]_i = \sum_{j=1}^n w_{ij}y_j,
            \end{equation*}\]</span>
          where the weights <span class="math inline">\(w_{ij}\)</span> consist of the elements of the
          <span class="math inline">\(i\)</span>-th row of the matrix <span class="math inline">\(\mathbf{W}\)</span>,
          matched up with the corresponding
          elements of the vector <span class="math inline">\(\mathbf{y}\)</span>.
        </p>
        <p>In other words, the spatial lag is a weighted
          sum of the values observed at neighboring locations, since the
          non-neighbors are not included (those <span class="math inline">\(i\)</span> for which <span
            class="math inline">\(w_{ij} =0\)</span>).
          Typically, the weights matrix is very sparse, so that only a small
          number of neighbors contribute to the weighted sum.
          For row-standardized weights, with <span class="math inline">\(\sum_j w_{ij} = 1\)</span>, the spatially
          lagged variable becomes
          a weighted average of the values at neighboring observations.</p>
        <p>In matrix notation, the spatial lag expression corresponds to
          the matrix product of the <span class="math inline">\(n \times n\)</span> spatial weights matrix <span
            class="math inline">\(\mathbf{W}\)</span>
          with the <span class="math inline">\(n \times 1\)</span> vector of observations <span
            class="math inline">\(\mathbf{y}\)</span>, or <span class="math inline">\(\mathbf{W \times y}\)</span>.
          The matrix <span class="math inline">\(\mathbf{W}\)</span> can therefore be considered to be the spatial
          lag <em>operator</em> on the vector <span class="math inline">\(\mathbf{y}\)</span>.</p>
        <p>In a number of applied contexts, it may be useful to include the observation at
          location <span class="math inline">\(i\)</span>
          itself in the weights computation. This implies that the diagonal elements of the
          weights matrix must be non-zero, i.e., <span class="math inline">\(w_{ii} \neq 0\)</span>. Depending on the
          context, the diagonal elements may take on the value of one or equal a specific value (e.g., for
          kernel weights where the kernel function is applied to the diagonal). We will
          highlight this issue in the specific illustrations that follow.</p>
      </div>
      <div id="creating-a-spatially-lagged-variable" class="section level3 unnumbered">
        <h3>Creating a spatially lagged variable</h3>
        <p>In GeoDa, the spatial lag computation is carried out through the <strong>Calculator</strong> dialog activated
          from the
          table menu (<strong>Table &gt; Calculator</strong>), and selecting the <strong>Spatial Lag</strong> tab. The
          <strong>Weight</strong>
          drop down list contains all the spatial weights available to the project,
          with the currently active weights listed. In the example illustrated in Figure <a
            href="#fig:spatiallagtab">2</a>,
          we use the contiguity defined by knn with 6 nearest neighbors, contained in the
          <strong>clev_sls_154_core_k6</strong> weights.
        </p>
        <div class="figure" style="text-align: center"><span id="fig:spatiallagtab"></span>
          <img src="pics4d/1_859_spatiallagtab.png" alt="Spatial Lag tab in calculator" width="60%" />
          <p class="caption">
            Figure 2: Spatial Lag tab in calculator
          </p>
        </div>
        <p>The process we follow is the usual one for creating new variables. We first <strong>Add</strong> a variable
          to
          the table and then initiate the particular computation to <strong>Apply</strong> to the variable. We next
          go over the four alternatives available through the interface.</p>
        <div id="spatial-lag-with-row-standardized-weights" class="section level4 unnumbered">
          <h4>Spatial lag with row-standardized weights</h4>
          <p>The default case is to <strong>Use row-standardized weights</strong> and to not include the diagonal
            weights (i.e., the observation itself) in the computation. For example, we can <strong>Add</strong> a
            variable
            <strong>LAG1</strong> (and include it <strong>after the last variable</strong> in the table). Next, we apply
            the spatial
            lag operation to the variable <strong>sale_price</strong>, as shown in Figure <a
              href="#fig:lagpricek6default">3</a>.
          </p>
          <div class="figure" style="text-align: center"><span id="fig:lagpricek6default"></span>
            <img src="pics4d/5_398_spatial_lag_price.png" alt="Spatial Lag for sales price" width="60%" />
            <p class="caption">
              Figure 3: Spatial Lag for sales price
            </p>
          </div>
          <p>After clicking on <strong>Apply</strong>, the new variable is entered into the table, as illustrated
            in Figure <a href="#fig:lagprice1">4</a>. In order to make it a little easier to compare the various
            computations, we moved the column for <strong>unique_id</strong> and <strong>sale_price</strong> over to the
            right, and
            placed them right next to the spatial lag, <strong>LAG1</strong>.</p>
          <div class="figure" style="text-align: center"><span id="fig:lagprice1"></span>
            <img src="pics4d/5_399_neighborsales.png" alt="Spatial Lag for sales price in table" width="80%" />
            <p class="caption">
              Figure 4: Spatial Lag for sales price in table
            </p>
          </div>
          <p>We quickly verify this operation by identifying the neighbors for the first location (with unique_id 1183)
            from the entries in the corresponding GWT file. As shown in Figure <a href="#fig:neighbors1183">5</a>, the
            six locations in question are those with unique_id 6842, 2024, 1624, 1198, 1741, and 2341.<a href="#fn2"
              class="footnote-ref" id="fnref2"><sup>2</sup></a></p>
          <div class="figure" style="text-align: center"><span id="fig:neighbors1183"></span>
            <img src="pics4d/1_013_k6_neighbors.png" alt="Neighbors for location 1183" width="35%" />
            <p class="caption">
              Figure 5: Neighbors for location 1183
            </p>
          </div>
          <p>We can also find the associated sales prices in the table (use the <strong>Selection Tool</strong> on the
            <strong>unique_id</strong> to find the relevant observations). They are listed in Figure <a
              href="#fig:neighborsales">6</a>, with the
            sales price for location 1183 on the first row.</p>
          <div class="figure" style="text-align: center"><span id="fig:neighborsales"></span>
            <img src="pics4d/1_001_k6prices.png" alt="Sales price for neighbors of location 1183" width="35%" />
            <p class="caption">
              Figure 6: Sales price for neighbors of location 1183
            </p>
          </div>
          <p>We now verify the value for the spatial lag listed in the table. It is obtained as the average of
            the sales price for the six neighbors, or (131650 + 65000 + 81500 + 76000 + 120000 + 5000)/6 = 79858.33.</p>
          <p>We can quickly assess the effect of the spatial averaging by comparing the descriptive statistics between
            the original price variable and its spatial lag (for example, by viewing the descriptive
            statistics associated with a histogram or box plot graph). The typical effect of the spatial lag is a
            compression of the range and variance of the variable. The range goes from $1,049 to $527,409 for
            the original variable to $6,583-$229,583 for the spatial lag. Similarly, the
            standard deviation is considerably reduced from 60,654 to 36,464.</p>
          <p>A more dramatic view of the influence of high-valued or low-valued neighbors on the spatial lag is given by
            the PCP. In several instances in the graph shown in Figure <a href="#fig:lagpcp">7</a>, the line goes from a
            high price to a much lower
            spatial lag, and vice versa. In other words, if there is high spatial heterogeneity in the data, the choice
            of the neighborhood (the spatial weights) becomes very important, and the
            spatial lag may not be a good proxy for the value observed at a given location (recall
            that the value at the given location is <em>not</em> included in the spatial lag calculation).
            This relates directly to the notion of <em>local spatial autocorrelation</em> that we will examine
            in a later chapter.</p>
          <div class="figure" style="text-align: center"><span id="fig:lagpcp"></span>
            <img src="pics4d/5_404_pcp.png" alt="PCP for sales price and its spatial lag" width="80%" />
            <p class="caption">
              Figure 7: PCP for sales price and its spatial lag
            </p>
          </div>
        </div>
        <div id="spatial-lag-as-a-sum-of-neighboring-values" class="section level4 unnumbered">
          <h4>Spatial lag as a sum of neighboring values</h4>
          <p>The default in GeoDa is to apply the spatial weights in row-standardized form. Hence the
            box associated with <strong>User row-standardized weights</strong> in Figure <a
              href="#fig:lagpricek6default">3</a>
            is checked by default. In some applications (for example, when dealing with 0-1 observations), one may be
            interested in the
            spatial lag computed with the original <em>binary</em> weights (i.e., without applying row-standardization).
            This is accomplished by unchecking the default box, as in Figure <a href="#fig:lagsum">8</a>.<a href="#fn3"
              class="footnote-ref" id="fnref3"><sup>3</sup></a></p>
          <div class="figure" style="text-align: center"><span id="fig:lagsum"></span>
            <img src="pics4d/1_863_spatiallagsum.png" alt="Spatial Lag sum for sales price" width="60%" />
            <p class="caption">
              Figure 8: Spatial Lag sum for sales price
            </p>
          </div>
          <p>The result is as shown in the table in Figure <a href="#fig:lagpsumtable">9</a>.</p>
          <div class="figure" style="text-align: center"><span id="fig:lagpsumtable"></span>
            <img src="pics4d/1_864_lag2intable.png" alt="Spatial Lag sum for sales price in table" width="40%" />
            <p class="caption">
              Figure 9: Spatial Lag sum for sales price in table
            </p>
          </div>
          <p>A quick check using the values from the table in Figure <a href="#fig:neighborsales">6</a>, reveals the
            lag sum for observation 1183 as 131650 + 65000 + 81500 + 76000 + 120000 + 5000 = 479150.</p>
          <p>In the case of knn weights, there may be some value in comparing the lag sums across observations. After
            all, since the number of neighbors is constant, these values are nothing but the original spatial lags
            scaled by a factor of k (i.e., six in our example). However, it is important to note that in most
            applications, the number of neighbors will not be constant
            across observations, in which case the sums will no longer be comparable.</p>
          <p>In the special case where the variable of interest is binary (0-1), the spatial lag sum will
            indicate the number of neighboring locations with an observation equal to 1. This is useful
            for computing join count statistics for local spatial autocorrelation, which we will consider in a later
            chapter.</p>
        </div>
        <div id="spatial-window-average" class="section level4 unnumbered">
          <h4>Spatial window average</h4>
          <p>A third notion of spatial lag based on the concept of connectivity is that of a spatial
            window average. This includes the value at the observation itself in the computation of the
            average. This option is invoked by checking both the <strong>Use row-standardized weights</strong>
            and the <strong>Include diagonal of weights matrix</strong> boxes in the interface, as illustrated
            in Figure <a href="#fig:windowavg">10</a>.</p>
          <div class="figure" style="text-align: center"><span id="fig:windowavg"></span>
            <img src="pics4d/1_865_windowavg.png" alt="Spatial window average for sales price" width="60%" />
            <p class="caption">
              Figure 10: Spatial window average for sales price
            </p>
          </div>
          <p>The result is inlcuded in our example table as variable <strong>LAG3</strong>, as shown in Figure <a
              href="#fig:lag3">11</a>.</p>
          <div class="figure" style="text-align: center"><span id="fig:lag3"></span>
            <img src="pics4d/1_866_lag3.png" alt="Spatial window average for sales price in table" width="55%" />
            <p class="caption">
              Figure 11: Spatial window average for sales price in table
            </p>
          </div>
          <p>In this calculation, the value for the location 1183 is the average of seven values,
            (235500 + 131650 + 65000 + 81500 + 76000 + 120000 + 5000)/7 = 102092.86.</p>
        </div>
        <div id="spatial-window-sum" class="section level4 unnumbered">
          <h4>Spatial window sum</h4>
          <p>Finally, we have the spatial window sum, the counterpart of the window average, but without
            using row-standardized weights. The corresponding box in the interface is thus unchecked,
            as in Figure <a href="#fig:windowsum">12</a>, but the <strong>Include diagonal of weights matrix</strong> is
            maintained.</p>
          <div class="figure" style="text-align: center"><span id="fig:windowsum"></span>
            <img src="pics4d/1_868_windowsum.png" alt="Spatial window sum for sales price" width="60%" />
            <p class="caption">
              Figure 12: Spatial window sum for sales price
            </p>
          </div>
          <p>The new variable <strong>LAG4</strong> is added to the table as in Figure <a href="#fig:lag4">13</a>.</p>
          <div class="figure" style="text-align: center"><span id="fig:lag4"></span>
            <img src="pics4d/1_869_lag4.png" alt="Spatial window sum for sales price in table" width="50%" />
            <p class="caption">
              Figure 13: Spatial window sum for sales price in table
            </p>
          </div>
          <p>The spatial window sum is simply the sum of the sales price for the observation at 1183 and
            its six neighbors, or,
            235500 + 131650 + 65000 + 81500 + 76000 + 120000 + 5000 = 714650. As in the case of the
            spatial lag sum, the spatial window sum may not be comparable among observations when the
            number of neighbors varies (for knn weights, the same number of neighbors is enforced
            by construction). When dealing with a binary variable, the spatial window sum corresponds to
            the number of <em>events</em> (observations with a value of 1) within the window centered
            on a location (including the
            value at that location).</p>
        </div>
      </div>
      <div id="spatially-lagged-variables-from-inverse-distance-weights" class="section level3 unnumbered">
        <h3>Spatially lagged variables from inverse distance weights</h3>
        <div id="principle" class="section level4 unnumbered">
          <h4>Principle</h4>
          <p>The spatial lag operation can also be applied using spatial weights calculated from the
            inverse distance between observations. As mentioned in our earlier discussion, the magnitude
            of these weights is highly scale dependent (depends on the scale of the coordinates). An uncritical
            application of a spatial lag operation with these weights can easily result in non-sensical
            values. More specifically, since the resulting weights can take on very small values, the
            spatial lag could end up being essentially zero.</p>
          <p>Formally, the spatial lag operation amounts to a weighted average of the neighboring values,
            with the inverse distance function as the weights:
            <span class="math display">\[[Wy]_i = \sum_j \frac{y_j}{d_{ij}^\alpha},\]</span>
            where in our implementation, <span class="math inline">\(\alpha\)</span> is either 1 or 2. In the latter
            case (a so-called gravity
            model weight), the spatial lag is sometimes referred to as a <em>potential</em> in geo-marketing analyses.
            It is a measure of how accessible location <span class="math inline">\(i\)</span> is to opportunities
            located in the neighboring
            locations (as defined by the weights).
          </p>
        </div>
        <div id="default-setting" class="section level4 unnumbered">
          <h4>Default setting</h4>
          <p>In contrast to the default setting for other weights, the preferred option for inverse distance
            weights is to keep the original values for the weights and <em>not</em> row-standardize,
            as illustrated in Figure <a href="#fig:invdistoptions">14</a>, with the two check boxes unchecked. Note how
            the selected weight is <strong>clev_sls_154_core_k6id</strong>, the inverse distance weights from our
            example.
            This selection triggers the particular default settings for the check boxes.</p>
          <div class="figure" style="text-align: center"><span id="fig:invdistoptions"></span>
            <img src="pics4d/2_875_invdistanceoptions.png" alt="Inverse distance lag default options" width="60%" />
            <p class="caption">
              Figure 14: Inverse distance lag default options
            </p>
          </div>
          <p>In all other respects, the lag computation proceeds in the same way as for connectivity weights.
            In the first step, a new variable is added to the table, followed by the actual calculation.</p>
          <p>The
            results of the various options are given in the four right-most columns of the
            table shown in Figure <a href="#fig:invdistlags">15</a>. The default case, with row-standardized weights off
            and no diagonal elements, is shown as the variable IDNRND. Compared to the original sales
            price, the lagged values are quite different. This is due to the scale of the inverse distance weights
            (the largest of which is 0.0026, see also Figure <a href="#fig:invdistweights">16</a>).</p>
          <div class="figure" style="text-align: center"><span id="fig:invdistlags"></span>
            <img src="pics4d/2_876_invdistlags.png" alt="Inverse distance spatial lags for sales price in table"
              width="60%" />
            <p class="caption">
              Figure 15: Inverse distance spatial lags for sales price in table
            </p>
          </div>
          <p>The third column, IDNRWD, shows the results when the diagonal is included (i.e., with
            the diagonal weights check box selected). This amounts to the
            value in IDNRND augmented by the sales price. For example, for the observation with unique_id 1183,
            the result is 397.521 + 235500 = 235897.521. This is equivalent to:
            <span class="math display">\[[Wy]_i = y_i + \sum_j \frac{y_j}{d_{ij}^\alpha}.\]</span>
            In some contexts, this may be the desired result, but it is by no means the most intuitive
            concept. It should therefore be used sparingly and only when there is a strong substantive
            motivation.
          </p>
        </div>
        <div id="spatial-lags-with-row-standardized-inverse-distance-weights" class="section level4 unnumbered">
          <h4>Spatial lags with row-standardized inverse distance weights</h4>
          <p>The original inverse distance weights are highly scale dependent. This can be remedied by
            expressing them in row-standardized form. The spatial lag then takes on the standard meaning of a
            weighted average of the values at neighboring observations. The main difference with lags
            computed for connectivity weights is that the neighbors are weighted differentially. As
            we saw earlier, in spatial lags
            based on connectivity weights all the neighboring values get the same weight.</p>
          <p>A comparison between the original inverse distance weights and their row-standardized form
            is given in Figure <a href="#fig:invdistweights">16</a>, for the six nearest neighbors associated with
            the location with unique_id 1183. Whereas the inverse distance weights sum to 0.0050, their
            row-standardized counterparts sum to 1, as desired.</p>
          <div class="figure" style="text-align: center"><span id="fig:invdistweights"></span>
            <img src="pics4d/2_002_inversedistanceweights.png" alt="Inverse distance weights" width="50%" />
            <p class="caption">
              Figure 16: Inverse distance weights
            </p>
          </div>
          <p>As a result, the spatial lag computed with row-standardized inverse distance weights is
            similar in scale to the original variable (and similar to the spatial lags based on connectivity
            weights). This is illustrated by the results in Figure <a href="#fig:invdistlags">15</a>, under the
            heading IDRSND.</p>
          <p>The fourth option is listed for completeness only, under the heading IDRSWD. In the
            implementation for connectivity weights, all observations end up with an equal weight.
            Specifically, this amounts to <span class="math inline">\(1 / (k_i + 1)\)</span>, where <span
              class="math inline">\(k_i\)</span> is the number of neighbors for
            observation <span class="math inline">\(i\)</span>. In contrast, in the inverse distance case, each
            neighboring observation
            is scaled by a different weight, so that it is not clear what weight should be given to
            the diagonal element. In GeoDa, the diagonal element gets the value of 1, so that the
            spatial lag amounts to:
            <span class="math display">\[[Wy]_i = y_i + \sum_j w_{ij} y_j.\]</span>
            Again, this should only be used when there is a strong substantive motivation.
          </p>
        </div>
      </div>
      <div id="spatially-lagged-variables-from-kernel-weights" class="section level3 unnumbered">
        <h3>Spatially lagged variables from kernel weights</h3>
        <p>Spatially lagged variables can also be computed from kernel weights. However, in this
          instance, only one of the options with respect to row-standardization and diagonal weights
          makes sense. Since the kernel weights are the result of a specific kernel function, they
          should not be altered. Also, each kernel function results in a specific value for the
          diagonal element, which should not be changed either. As a result, the only viable option
          to create spatially lagged variables based on kernel weights is to have no row-standardization
          and have the diagonal elements included.</p>
        <p>When the calculator spatial lag interface detects
          the selection of kernel weights, the options are greyed out, with the diagonal elements
          checked, as in Figure <a href="#fig:kerneloptions">17</a>.<a href="#fn4" class="footnote-ref"
            id="fnref4"><sup>4</sup></a> The entry in the
          weight box, <strong>clev_sls_154_core_k6epadiag</strong>, refers to the Epanechnikov kernel weights computed
          for 6 nearest neighbors.</p>
        <div class="figure" style="text-align: center"><span id="fig:kerneloptions"></span>
          <img src="pics4d/3_877_epadialog.png" alt="Kernel weights lag default options" width="60%" />
          <p class="caption">
            Figure 17: Kernel weights lag default options
          </p>
        </div>
        <p>The resulting spatially lagged variable is
          <span class="math display">\[[Wy]_i = \sum_j K_{ij} y_j,\]</span>
          where the sum includes the diagonal element of the kernel weight <span class="math inline">\(K_{ij}\)</span>.
          The results
          for the Epanechnikov weights (with 0.75 on the diagonal) are shown in Figure <a href="#fig:epalags">18</a>,
          under the heading EPALAG.
        </p>
        <div class="figure" style="text-align: center"><span id="fig:epalags"></span>
          <img src="pics4d/3_878_epalag.png" alt="Epanechnikov kernel spatial lags for sales price in table"
            width="30%" />
          <p class="caption">
            Figure 18: Epanechnikov kernel spatial lags for sales price in table
          </p>
        </div>
        <p>Kernel-based spatially lagged variables correspond to a form of local smoothing. They
          can be used in specialized regression specifications, such as geographically weighted
          regression (GWR).<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a></p>
      </div>
    </div>
    <div id="spatial-rate-smoothing" class="section level2 unnumbered">
      <h2>Spatial rate smoothing</h2>
      <div id="principle-1" class="section level4 unnumbered">
        <h4>Principle</h4>
        <p>A spatial rate smoother is a special case of a nonparameteric rate estimator, based on
          the principle of locally weighted estimation <span class="citation">(see, e.g., Waller and Gotway <a
              href="#ref-WallerGotway:04">2004</a>, 89–90)</span>. Rather than applying a local average to the
          rate itself, as in an application of a spatial window average, the weighted
          average is applied separately to the numerator and denominator.</p>
        <p>The spatially smoothed rate for a given location <span class="math inline">\(i\)</span> is then given as:
          <span class="math display">\[\pi_i = \frac{\sum_{j=1}^n w_{ij} O_j}{\sum_{j=1}^n w_{ij} P_j},\]</span>
          where <span class="math inline">\(O_j\)</span> is the event count in location <span
            class="math inline">\(j\)</span>, <span class="math inline">\(P_j\)</span> is the population at risk,
          and <span class="math inline">\(w_{ij}\)</span> are the spatial weights (typically with <span
            class="math inline">\(w_{ii} \neq 0\)</span>, i.e., including the
          diagonal).
        </p>
        <p>Different smoothers are obtained for different spatial definitions of neighbors
          and/or different weights applied to those neighbors (e.g., contiguity weights, inverse
          distance weights, or kernel weights).<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p>
        <p>An early example was the spatial rate smoother outlined in <span class="citation">Kafadar (<a
              href="#ref-Kafadar:96">1996</a>)</span>, based
          on the notion of a spatial moving average or <em>window average</em> <span class="citation">(see also Kafadar
            <a href="#ref-Kafadar:97">1997</a>)</span>. The window
          average is not applied to the rate itself, but it is computed separately for the numerator and denominator.
          The simplest case boils down to applying the idea of a <em>spatial window sum</em> to the
          numerator and denominator (i.e., with binary spatial weights in both, and including the
          diagonal term):
          <span class="math display">\[ \pi_i = \frac{O_i + \sum_{j=1}^{J_i} O_j}{P_i + \sum_{j=1}^{J_i} P_j},\]</span>
          where <span class="math inline">\(J_i\)</span> is a reference set (neighbors) for observation <span
            class="math inline">\(i\)</span>. In practice,
          this is achieved by using binary spatial weights for both numerator and denominator, and
          including the diagonal in both terms, as in the expression above.
        </p>
        <p>A map of spatially smoothed rates tends to emphasize broad spatial trends and is useful
          for identifying general features of the data. However, it is not useful for the analysis
          of spatial autocorrelation, since the smoothed rates are autocorrelated by construction.
          It is also not very useful for identifying outlying observations, since the values
          portrayed are really regional averages and not specific to an individual location.
          By construction, the values shown for individual locations are determined by both the events
          and the population sizes of adjoining spatial units, which can lead to misleading impressions.
          Often, inverse distance weights are applied to both the numerator and denominator, e.g.,
          as in the early discussion by <span class="citation">Kafadar (<a href="#ref-Kafadar:96">1996</a>)</span>.</p>
      </div>
      <div id="preliminaries" class="section level4 unnumbered">
        <h4>Preliminaries</h4>
        <p>We return to the rate smoothing examples using the Ohio county lung cancer data. Therefore,
          we need
          to close the current project and load the <strong>ohlung</strong> data set.</p>
        <p>Next, we need to create the
          spatial weights files we will use if we don’t have them already stored in a project file. In order to make
          sure that some smoothing will occur, we
          take a fairly wide definition of neighbors.<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>
          Specifically, we will create a second order queen contiguity,
          inclusive of first order neighbors, inverse distance weights based on knn = 10 nearest neighbor
          weights, and Epanechnikov kernel weights, using the same 10 nearest neighbors and with the kernel
          applied to the diagonal (its value will be 0.75).</p>
        <p>We proceed in the usual manner and use <strong>FIPSNO</strong> as the ID variable. The creation of the
          queen contiguity weights is straightforward (we name the file <strong>ohlung_q2inc</strong>). We postpone the
          creation of the inverse distance
          and kernel weights until the next section.</p>
        <p>In addition to the spatial weights, we also need an example for crude rates. If not already
          saved in the data set, we compute the crude rate for lung cancer among white females in 68.</p>
        <p>Using the
          <strong>Rates</strong> tab in the calculator, we first add a new variable, e.g., <strong>LRATE</strong>, then
          compute
          the crude rate with <strong>LFW68</strong> as the <strong>Event Variable</strong> and <strong>POPFW68</strong>
          as the <strong>Base Variable</strong>. In order to present the results on a more intuitive scale, we also
          multiply
          <strong>LRATE</strong> by 10,000, using the <strong>Bivariate</strong> tab with the <strong>Multiply</strong>
          function (the result gives the number of lung cancer cases per 10,000 white
          females). A standard deviational map for the rates, shown in Figure <a href="#fig:ohcruderatemap">19</a>,
          illustrates the familiar pattern from the Chapter on mapping rates.
        </p>
        <div class="figure" style="text-align: center"><span id="fig:ohcruderatemap"></span>
          <img src="pics4d/6_406_crudestdevmap.png" alt="Standard deviational map for crude rates" width="80%" />
          <p class="caption">
            Figure 19: Standard deviational map for crude rates
          </p>
        </div>
      </div>
      <div id="digression---rescaling-coordinates" class="section level4 unnumbered">
        <h4>Digression - rescaling coordinates</h4>
        <p>As pointed out in the discussion of inverse distance weights, the resulting values for the
          weights depend critically on the scale in which the (centroid) coordinates are expressed.
          In the example for Ohio counties, the unit of measurement is feet, which results in very large
          values for the coordinates. For example, if we use <strong>Shape Centers &gt; Add Centroids to Table</strong>
          from
          the map, we can inspect the actual values under <strong>COORD_X</strong> and <strong>COORD_Y</strong> in the
          table
          shown in Figure <a href="#fig:ohnewcoords">20</a>.</p>
        <div class="figure" style="text-align: center"><span id="fig:ohnewcoords"></span>
          <img src="pics4d/7_879_newcoordsOH.png" alt="Rescaled centroid coordinates for Ohio counties" width="60%" />
          <p class="caption">
            Figure 20: Rescaled centroid coordinates for Ohio counties
          </p>
        </div>
        <p>The magnitudes are in the hundreds of thousands and even in the millions (for the y-coordinate). As a
          result, the inter-point distances will be very large, and the corresponding inverse distance
          measures will be very small. For example, in the left-hand panel of Figure <a href="#fig:ohinvdistwts">21</a>,
          we see the inverse distance weights for the 10 nearest neighbors of the county with FIPSNO 39095
          (Lucas county, OH). The weights are all smaller than 0.0001. This will result in spatially lagged
          values that are very close to zero, and will not provide a meaningful averaging.</p>
        <div class="figure" style="text-align: center"><span id="fig:ohinvdistwts"></span>
          <img src="pics4d/7_014_invdistwts_oh.png" alt="Inverse distance weights for Ohio counties" width="80%" />
          <p class="caption">
            Figure 21: Inverse distance weights for Ohio counties
          </p>
        </div>
        <p>In order to fix this problem, we need to rescale the original coordinates. Using the calculator tool in the
          table, we create two new variables, <strong>X</strong> and <strong>Y</strong>, that are the original
          coordinates divided by 10000
          (as above in the rescaling of the crude rates, use the <strong>Bivariate</strong> tab with the
          <strong>Divide</strong> function).
          The results are shown in the <strong>X</strong> and <strong>Y</strong> columns of Figure <a
            href="#fig:ohnewcoords">20</a>, and now
          represent units of 10000 feet.</p>
        <p>As we have seen, we can use any two variables as coordinates for the distance weights. By
          selecting <strong>X</strong> and <strong>Y</strong>, we create a set of inverse distance weights to the 10
          nearest
          neighors (as <strong>ohlung_k10invd</strong>). The corresponding values for the weights are shown in the
          right-hand panel of Figure <a href="#fig:ohinvdistwts">21</a>. Compared to the original set, these are much
          more reasonable (all are larger than 0.1).</p>
        <p>In addition to the queen contiguity and inverse distance weights, we also create Epanechnikov
          kernel weights (with the kernel applied to the diagonal) using an adaptive kernel for 10
          nearest neighbors (i.e., with the same range as the inverse distance weights). We again use
          the <strong>X</strong> and <strong>Y</strong> coordinates to compute the distances. This yields the weights
          <strong>ohlung_epa</strong>.
        </p>
        <p>At this point, we should have the three spatial weights listed in the weights manager panel, as in
          Figure <a href="#fig:ohwtsman">22</a>. In our example, we show the properties of the second order contiguity
          weights. The number of neighbors ranges from 7 to 22, with an average of 14.64, which will yield
          some degree of smoothing. Of course, for the inverse distance and kernel weights, the number of neighbors is
          10
          for all counties.</p>
        <div class="figure" style="text-align: center"><span id="fig:ohwtsman"></span>
          <img src="pics4d/7_880_OH_weights.png" alt="Weights manager for Ohio counties" width="60%" />
          <p class="caption">
            Figure 22: Weights manager for Ohio counties
          </p>
        </div>
        <p>We are now ready to proceed with the analysis.</p>
      </div>
      <div id="simple-window-average-of-rates" class="section level4 unnumbered">
        <h4>Simple window average of rates</h4>
        <p>First, we illustrate how <em>not</em> to proceed, but use this as a reference. We compute
          the lag variable as a <em>window average</em>, using the settings in the calculator. We
          select the <strong>Spatial Lag</strong>
          tab shown in Figure <a href="#fig:windowavg">10</a>, with both the <strong>Use row-standardized
            weights</strong>
          and the <strong>Include diagonal of weights matrix</strong> boxes checked in the interface. We
          specify <strong>ohlung_q2inc</strong> as the spatial weight and <strong>LRATE</strong> as the variable. The
          window average is contained in the new variable <strong>W_LRATE</strong>. The calculator interface should be
          as in Figure <a href="#fig:ratewindowavg">23</a>.</p>
        <div class="figure" style="text-align: center"><span id="fig:ratewindowavg"></span>
          <img src="pics4d/6_405_windowavg_rate.png" alt="Spatial window average of crude rates" width="60%" />
          <p class="caption">
            Figure 23: Spatial window average of crude rates
          </p>
        </div>
        <p>The corresponding standard deviational map is given in Figure <a href="#fig:avgratemap">24</a>.</p>
        <div class="figure" style="text-align: center"><span id="fig:avgratemap"></span>
          <img src="pics4d/6_408_wratestdevmap.png" alt="Crude rate spatial window average" width="80%" />
          <p class="caption">
            Figure 24: Crude rate spatial window average
          </p>
        </div>
        <p>Characteristic of the spatial averaging, several larger groupings of similarly classified
          observations appear. The pattern is quite different from that displayed for the crude rate
          in Figure <a href="#fig:ohcruderatemap">19</a>. For example, the upper outliers have disappeared, and there is
          now one new lower outlier.</p>
      </div>
      <div id="spatially-smoothed-rates" class="section level4 unnumbered">
        <h4>Spatially smoothed rates</h4>
        <p>As mentioned, applying the spatial averaging directly to the crude rates is <em>not</em> the proper way to
          operate. This approach ignores the
          differences between the populations of the different counties and the associated variance
          instability of the rates. The <strong>Spatial Rate</strong> smoothing option is the correct alternative,
          which applies the smoothing separately to the observations as they enter into the numerator
          and the denominator of the rate calculation.</p>
        <p>We invoke this calculation either from the menu, as <strong>Map &gt; Rates-Calculated Map &gt; Spatial
            Rate</strong>,
          or by right-clicking on the current map and selecting <strong>Rates &gt; Spatial Rate</strong>, as shown in
          Figure <a href="#fig:spatialrateoption">25</a>.</p>
        <div class="figure" style="text-align: center"><span id="fig:spatialrateoption"></span>
          <img src="pics4d/6_883_spatialrateoption.png" alt="Spatial rate option" width="40%" />
          <p class="caption">
            Figure 25: Spatial rate option
          </p>
        </div>
        <p>The dialog that appears, shown in Figure <a href="#fig:spatialratedial">26</a>, is the usual interface
          for rate calculation. It requires the selection of the <strong>Event Variable</strong>
          (<strong>LFW68</strong>),
          the <strong>Base Variable</strong> (<strong>POPFW68</strong>), the <strong>Map Theme</strong>
          (<strong>Standard Deviation Map</strong>),
          and a specification for the spatial weights (<strong>ohlung_q2inc</strong>).<a href="#fn8"
            class="footnote-ref" id="fnref8"><sup>8</sup></a></p>
        <div class="figure" style="text-align: center"><span id="fig:spatialratedial"></span>
          <img src="pics4d/6_409_spatialrate.png" alt="Spatial rate dialog" width="50%" />
          <p class="caption">
            Figure 26: Spatial rate dialog
          </p>
        </div>
        <p>Clicking <strong>OK</strong> brings up a standard deviation map with the smoothed rates, shown
          in Figure <a href="#fig:spatialratemap">27</a>.</p>
        <p>In order
          to make the category ranges meaningful, we use a legend option to give the results
          in scientific notation (right click on the legend pane and
          select <strong>Use Scientific Notation</strong>). Again, we
          observe the larger groupings of observations, but now several outliers remain, although
          not in the same locations as for the crude rate.</p>
        <div class="figure" style="text-align: center"><span id="fig:spatialratemap"></span>
          <img src="pics4d/6_410_spatialratemap.png" alt="Spatial rate smoothed map" width="80%" />
          <p class="caption">
            Figure 27: Spatial rate smoothed map
          </p>
        </div>
        <p>We add the smoothed rates to the data table by means of the <strong>Save Rates</strong> option
          (keeping the default variable name of <strong>R_SPAT_R</strong>). As we did above for <strong>LRATE</strong>,
          we multiply the ratio
          by 10,000 in the calculator to make the results easier to interpret. The three sets of
          rates are shown in the table in Figure <a href="#fig:spatialratetable">28</a> for the first ten counties.</p>
        <div class="figure" style="text-align: center"><span id="fig:spatialratetable"></span>
          <img src="pics4d/6_885_spatialratestable.png" alt="Comparison of smoothed rates in table" width="35%" />
          <p class="caption">
            Figure 28: Comparison of smoothed rates in table
          </p>
        </div>
        <p>A more quantified comparison is obtained from a scatter plot of <strong>W_LRATE</strong> against
          <strong>R_SPAT_RT</strong>. As is clear from Figure <a href="#fig:ratescatplot">29</a>, the values are far
          from
          the same. In fact, the R<sup>2</sup> of the linear fit is only 0.60.
        </p>
        <div class="figure" style="text-align: center"><span id="fig:ratescatplot"></span>
          <img src="pics4d/6_411_scatplotrates.png" alt="Comparison of spatial rates" width="60%" />
          <p class="caption">
            Figure 29: Comparison of spatial rates
          </p>
        </div>
      </div>
      <div id="spatially-smoothed-rates-in-the-table" class="section level4 unnumbered">
        <h4>Spatially smoothed rates in the table</h4>
        <p>The spatial rate smoothing option is only implemented for contiguity weights, i.e., an unweighted
          average is calculated for both the numerator and denominator. Of course, we can also carry
          this out explicitly, by creating separate spatially lagged variables for the counts of events and
          for the populations at risk (using the <em>spatial window average</em> operation covered earlier), followed
          by their ratio (and possibly scaling by a factor such as 10000).</p>
        <p>If inverse distance or kernel weights are specified in the spatial rate variable setting dialog
          (Figure <a href="#fig:spatialratedial">26</a>), the values for the weights are ignored, and only the
          connectivity information is taken into account to compute the averages. As an alternative, we
          can carry out the explicit spatial lag calculation for the numerator and denominator, which
          will use the actual weights in the computation. This is can be accomplished with the
          <strong>Calculator</strong> option in the table.
        </p>
        <p>We first proceed with the inverse distance weights (<strong>ohlung_k10invd</strong>). We proceed in the
          calculator in turn for the numerator and denominator. We add a new variable for each, and
          then compute the spatial window sum using the inverse distance weights applied to <strong>LFW68</strong> and
          <strong>POPFW68</strong>. The options should be set to not row-standardize the weights and to include
          the diagonal (the option should be checked as in Figure <a href="#fig:windowsum">12</a>). We next create
          a new variable, <strong>IDRATE</strong>, as the ratio of the numerator over the denominator, and rescale by
          multiplying with 10000. The corresponding standard devational map is shown
          in Figure <a href="#fig:idratemap">30</a>.
        </p>
        <div class="figure" style="text-align: center"><span id="fig:idratemap"></span>
          <img src="pics4d/7_889_idratemap.png" alt="Inverse distance spatial rate smoothed map" width="80%" />
          <p class="caption">
            Figure 30: Inverse distance spatial rate smoothed map
          </p>
        </div>
        <p>We can also apply the same technique to kernel weights, e.g. using <strong>ohlung_epa</strong>. Following the
          same steps as for the inverse distance weights, with the same settings in the dialog will yield
          rates that are smoothed using the weights determined by the kernel function. This yields the
          standard deviational map shown in Figure <a href="#fig:kernratemap">31</a>.</p>
        <div class="figure" style="text-align: center"><span id="fig:kernratemap"></span>
          <img src="pics4d/7_890_kernrate.png" alt="Kernel weights spatial rate smoothed map" width="80%" />
          <p class="caption">
            Figure 31: Kernel weights spatial rate smoothed map
          </p>
        </div>
        <p>It is important to keep in mind that both the inverse distance and kernel weights spatially smoothed
          rates are based on a particular trade-off between the value at the location and its neighbors. This
          trade-off depends critically on the distance metric used in the calculations (or, on the scale
          in which the coordinates are expressed). There is no right answer, and a thorough sensitivity
          analysis is advised.</p>
        <p>For example, we can observe that the three spatially smoothed maps in Figures
          <a href="#fig:spatialratemap">27</a>, <a href="#fig:idratemap">30</a>, and <a href="#fig:kernratemap">31</a>
          point to some elevated
          rates in the south of the state, but the extent of the respective regions and the counties on
          which they are centered differ slightly. Also, the general regional patterns are roughly the
          same, but there are important differences in terms of the specific counties affected.
        </p>
        <p>In the table shown in Figure <a href="#fig:allratesintable">32</a>, we summarize all the rates computed in
          this
          section:
          <strong>LRATE</strong> is the crude rate, <strong>W_LRATE</strong> it its queen contiguity based spatial lag,
          <strong>R_SPAT_RT</strong> is the spatially smoothed rate saved from the calculation, <strong>IDRATE</strong>
          is the
          rate based on inverse distance weights, <strong>KERN_RATE</strong> the kernel-smoothed rate, and
          <strong>S_LRATE</strong>
          is the spatially smoothed rate computed in the table as an explicit ratio between numerator
          and denominator (it is identical to the result from the direct rate calculation in
          <strong>R_SPAT_RT</strong>).
        </p>
        <div class="figure" style="text-align: center"><span id="fig:allratesintable"></span>
          <img src="pics4d/7_891_allratesintable.png" alt="All spatially smoothed rates in the table" width="60%" />
          <p class="caption">
            Figure 32: All spatially smoothed rates in the table
          </p>
        </div>
      </div>
    </div>
    <div id="spatial-empirical-bayes-smoothing" class="section level2 unnumbered">
      <h2>Spatial Empirical Bayes smoothing</h2>
      <div id="principle-2" class="section level3 unnumbered">
        <h3>Principle</h3>
        <p>The second option for spatial rate smoothing is <strong>Spatial Empirical Bayes</strong>. This operates in
          the same way as the standard Empirical Bayes smoother (covered in the rate mapping Chapter), except that the
          reference rate is
          computed for a spatial window for each individual observation, rather than taking the same
          overall reference rate for all. This only works well for larger data sets, when the window
          (as defined by the spatial weights) is large enough to allow for effective smoothing.</p>
        <p>Similar to the standard EB principle, a reference rate (or prior) is computed. However, here,
          this rate is estimated from the <em>spatial window</em> surrounding a given observation, consisting
          of the observation and its neighbors. The neighbors are defined by the non-zero elements in the
          row of the spatial weight matrix (i.e., the spatial weights are treated as binary).</p>
        <p>Formally,
          the reference mean for location <span class="math inline">\(i\)</span> is then:
          <span class="math display">\[\mu_i = \frac{\sum_j w_{ij} O_j}{\sum_j w_{ij} P_j},\]</span>
          with <span class="math inline">\(w_{ij}\)</span> as binary spatial weights, and <span
            class="math inline">\(w_{ii} = 1\)</span>.
        </p>
        <p>The local estimate of the prior variance follows the same logic as for EB, but replacing
          the population and rates by their local counterparts:
          <span class="math display">\[\sigma^2_i = \frac{\sum_j w_{ij}[ P_j (r_i - \mu_i)^2] }{\sum_j w_{ij} P_j} -
            \frac{\mu_i}{\sum_j w_{ij} P_i / (k_i +1)}.\]</span>
          Note that the average population in the second term pertains to all locations within the window, therefore,
          this is divided by <span class="math inline">\(k_i + 1\)</span> (with <span class="math inline">\(k_i\)</span>
          as the number of neighbors of <span class="math inline">\(i\)</span>). As in the case of the standard EB rate,
          it is
          quite possible (and quite common) to obtain a negative estimate for the local variance, in which case it is
          set to zero.
        </p>
        <p>The spatial EB smoothed rate is computed as a weighted average of the crude rate and the prior, in
          the same manner as for the standard EB rate <span class="citation">(see the discussion in the Chapter on
            mapping rates,
            as well as Anselin, Lozano-Gracia, and Koschinky <a href="#ref-Anselinetal:06c">2006</a>, for technical
            details)</span>.</p>
      </div>
      <div id="spatial-eb-rate-smoother" class="section level3 unnumbered">
        <h3>Spatial EB rate smoother</h3>
        <p>The spatial Empirical Bayes rate smoother is invoked from the menu as <strong>Map &gt; Rates-Calculated Map
            &gt; Spatial Empirical Bayes</strong>, or from the option menu in any map, as <strong>Rates &gt; Spatial
            Empirical Bayes</strong>. The
          latter is illustrated in Figure <a href="#fig:spatialEBoption">33</a>.</p>
        <div class="figure" style="text-align: center"><span id="fig:spatialEBoption"></span>
          <img src="pics4d/8_892_spatialeboption.png" alt="Spatial Empirical Bayes option" width="40%" />
          <p class="caption">
            Figure 33: Spatial Empirical Bayes option
          </p>
        </div>
        <p>The variable settings dialog is identical to that for the spatial rate smoother, as shown
          in Figure <a href="#fig:spatialratedial">26</a>. We can use the exact same settings, with the second order
          queen contiguity defining the range of the window for each observation.</p>
        <p>Using these settings, a standard deviational map of the smoothed rates is as in
          Figure <a href="#fig:spatialEBmapqueen">34</a>.</p>
        <div class="figure" style="text-align: center"><span id="fig:spatialEBmapqueen"></span>
          <img src="pics4d/8_894_spatialebqueen.png" alt="Spatial EB rate using second order queen contiguity"
            width="80%" />
          <p class="caption">
            Figure 34: Spatial EB rate using second order queen contiguity
          </p>
        </div>
        <p>Selecting the inverse distance weights results in the map shown in Figure <a
            href="#fig:spatialEBmapknn">35</a>.
          Note that the actual inverse distance weights are ignored, but only used to identify the 10 nearest neighbors
          for each location. This defines the spatial window for which the local priors are computed.</p>
        <div class="figure" style="text-align: center"><span id="fig:spatialEBmapknn"></span>
          <img src="pics4d/8_895_spatialebinvd.png" alt="Spatial EB rate using k = 10 nearest neighbors" width="80%" />
          <p class="caption">
            Figure 35: Spatial EB rate using k = 10 nearest neighbors
          </p>
        </div>
        <p>As for the spatial rate smoothing approaches, a careful sensitivity analysis is in order. The results
          depend considerably on the range used for the reference rate. The larger the range, the more the smoothed
          rates will be similar to the global EB rate. For a narrow range, the estimate of the local variance will
          often result in a zero imputed value, which makes the EB approach less meaningful.</p>
      </div>
    </div>
    <div id="references" class="section level2 unnumbered">
      <h2>References</h2>
      <div id="refs" class="references">
        <div id="ref-Anselinetal:06c">
          <p>Anselin, Luc, Nancy Lozano-Gracia, and Julia Koschinky. 2006. “Rate Transformations and Smoothing.”
            Technical Report. Urbana, IL: Spatial Analysis Laboratory, Department of Geography, University of Illinois.
          </p>
        </div>
        <div id="ref-Fotheringhametal:02">
          <p>Fotheringham, A. Stewart, Chris Brunsdon, and Martin Charlton. 2002. <em>Geographically Weighted
              Regression</em>. Chichester: John Wiley.</p>
        </div>
        <div id="ref-Kafadar:96">
          <p>Kafadar, Karen. 1996. “Smoothing Geographical Data, Particularly Rates of Disease.” <em>Statistics in
              Medicine</em> 15:2539–60.</p>
        </div>
        <div id="ref-Kafadar:97">
          <p>———. 1997. “Geographic Trends in Prostate Cancer Mortality: An Application of Spatial Smoothers and the
            Need for Adjustment.” <em>Annals of Epidemiology</em> 7:35–45.</p>
        </div>
        <div id="ref-WallerGotway:04">
          <p>Waller, Lance A., and Carol A. Gotway. 2004. <em>Applied Spatial Statistics for Public Health Data</em>.
            Hoboken, NJ: John Wiley.</p>
        </div>
      </div>
    </div>
    <div class="footnotes">
      <hr />
      <ol>
        <li id="fn1">
          <p>University of Chicago, Center for Spatial Data Science – <a
              href="mailto:anselin@uchicago.edu">anselin@uchicago.edu</a><a href="#fnref1" class="footnote-back">↩</a>
          </p>
        </li>
        <li id="fn2">
          <p>The GWT
            file also includes the respective distances, but these are ignored in the spatial lag operations.<a
              href="#fnref2" class="footnote-back">↩</a></p>
        </li>
        <li id="fn3">
          <p>After
            re-arranging the columns in the table, the variable name listed under <strong>Variable</strong> in the
            interface
            may have changed. In our example, it should be <strong>sale_price</strong>.<a href="#fnref3"
              class="footnote-back">↩</a></p>
        </li>
        <li id="fn4">
          <p>While this option is not available as a selection, it is set by default. Displaying
            the check mark in the interface makes clear which options are being used.<a href="#fnref4"
              class="footnote-back">↩</a></p>
        </li>
        <li id="fn5">
          <p>GWR is not implemented in GeoDa. For further details on the use
            of kernel-based spatially lagged variables in GWR, see, e.g., <span class="citation">Fotheringham, Brunsdon,
              and Charlton (<a href="#ref-Fotheringhametal:02">2002</a>)</span>.<a href="#fnref5"
              class="footnote-back">↩</a></p>
        </li>
        <li id="fn6">
          <p>For further details, see <span class="citation">Anselin, Lozano-Gracia, and Koschinky (<a
                href="#ref-Anselinetal:06c">2006</a>)</span>, Section 5.2.<a href="#fnref6" class="footnote-back">↩</a>
          </p>
        </li>
        <li id="fn7">
          <p>If the <em>spatial window</em> over which the average
            is computed is not sufficiently
            wide, such as with first order contiguity weights, very little smoothing occurs, and
            the results may be somewhat erratic.<a href="#fnref7" class="footnote-back">↩</a></p>
        </li>
        <li id="fn8">
          <p>Alternatively, we
            can compute the spatial rates in the calculator, using the <strong>Rates</strong> tab. Note that
            the weights information in inverse distance weights and kernel weights is ignored in
            this operation, only the connectivity is used to compute the spatial averages.<a href="#fnref8"
              class="footnote-back">↩</a></p>
        </li>
      </ol>
    </div>


  </section>


  <!-- dynamically load mathjax for compatibility with self-contained -->
  <script>
    (function () {
      var script = document.createElement("script");
      script.type = "text/javascript";
      script.src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
      document.getElementsByTagName("head")[0].appendChild(script);
    })();
  </script>

</body>

</html>
